mod byteconv;
mod reader;
mod tag;
mod value;
mod writer;

use clap::Parser;
use thiserror::Error;

#[derive(Parser)]
enum Opt {
    /// Decode a storage file to RON on stdout
    Decode {
        /// Input storage binary file
        file: String,
    },
    /// Encode a RON file to a storage file
    Encode {
        /// Input RON file, generated by the decode subcommand
        #[clap(short, long)]
        input: String,
        /// Output storage binary file
        #[clap(short, long)]
        output: String,
    },
}

#[derive(Debug, Error)]
enum Error {
    #[error(transparent)]
    Decode(#[from] reader::Error),
    #[error(transparent)]
    Ron(#[from] ron::Error),
    #[error(transparent)] // Additionally includes position
    RonSpanned(#[from] ron::de::SpannedError),
    #[error(transparent)]
    Io(#[from] std::io::Error),
}

type Result<T> = std::result::Result<T, Error>;

fn main() -> Result<()> {
    let opt = Opt::parse();
    match opt {
        Opt::Decode { file } => {
            let data = reader::decode(&file)?;

            let config = ron::ser::PrettyConfig::default().compact_structs(true);

            let json = ron::ser::to_string_pretty(&data, config)?;

            println!("{}", json);
        }
        Opt::Encode { input, output } => {
            let input = std::fs::File::open(&input)?;
            let data: value::Value = ron::de::from_reader(input)?;

            let mut output = std::fs::File::create(&output)?;
            writer::encode(data, &mut output)?;
            output.sync_all()?;
        }
    }

    Ok(())
}
