mod byteconv;
mod reader;
mod tag;
mod value;
mod writer;

use clap::Parser;
use thiserror::Error;

use crate::value::{Table, Value};

#[derive(Parser)]
enum Opt {
    /// Decode a storage file to RON on stdout
    Decode {
        /// Input storage binary file
        file: String,

        /// List of fields to drop from output. Can be nested such as "foo.bar.baz".
        /// No-op if the field does not exist
        #[clap(long)]
        drop: Vec<String>,

        /// Similar to drop, but drops all fields that start with the given prefix
        /// Does not support nested fields. No-op if no matching fields are found
        #[clap(long)]
        drop_starts_with: Vec<String>,
    },
    /// Encode a RON file to a storage file
    Encode {
        /// Input RON file, generated by the decode subcommand
        #[clap(short, long)]
        input: String,
        /// Output storage binary file
        #[clap(short, long)]
        output: String,
    },
}

#[derive(Debug, Error)]
enum Error {
    #[error(transparent)]
    Decode(#[from] reader::Error),
    #[error(transparent)]
    Ron(#[from] ron::Error),
    #[error(transparent)] // Additionally includes position
    RonSpanned(#[from] ron::de::SpannedError),
    #[error(transparent)]
    Io(#[from] std::io::Error),
}

type Result<T> = std::result::Result<T, Error>;

/// Drop a field by path
/// no-op if the field does not exist
fn drop_field(table: &mut Table, field: &[&str]) {
    match field.len() {
        // [field] should always have at least one element, otherwise we would have stopped already
        // and the argument will have always split into at least one element
        0 => unreachable!(),
        1 => {
            // Clone is sub-optimal, but performance here is not critical
            table.remove(&Value::String(field[0].to_string()));
        }
        _ => {
            let key = field[0];
            let nested = &field[1..];
            if let Some(Value::Table(value)) = table.get_mut(&Value::String(key.to_string())) {
                drop_field(value, nested);
            }
        }
    }
}

fn cleanup(table: &mut Table, drop_paths: &Vec<String>, drop_starts_with: &Vec<String>) {
    for field in drop_paths {
        let path = field.split('.').collect::<Vec<&str>>();
        drop_field(table, &path);
    }

    for pat in drop_starts_with {
        let to_remove = table
            .keys()
            .filter_map(|key| match key {
                Value::String(str) => {
                    if str.starts_with(pat) {
                        // Clones the string, removing the borrow that would keep
                        // it from being dropped
                        Some(str.to_string())
                    } else {
                        None
                    }
                }
                _ => None,
            })
            .collect::<Vec<_>>();
        for key in to_remove {
            table.remove(&Value::String(key));
        }
    }
}

fn main() -> Result<()> {
    let opt = Opt::parse();
    match opt {
        Opt::Decode {
            file,
            drop,
            drop_starts_with,
        } => {
            let mut data = reader::decode(&file)?;
            if let Value::Table(ref mut table) = &mut data {
                // We have to decode everything, even parts we're dropping as, tables
                // don't store their length: it has to be inferred from the data.
                cleanup(table, &drop, &drop_starts_with);
            }

            let config = ron::ser::PrettyConfig::default().compact_structs(true);

            let json = ron::ser::to_string_pretty(&data, config)?;

            println!("{}", json);
        }
        Opt::Encode { input, output } => {
            let input = std::fs::File::open(&input)?;
            let data: value::Value = ron::de::from_reader(input)?;

            let mut output = std::fs::File::create(&output)?;
            writer::encode(data, &mut output)?;
            output.sync_all()?;
        }
    }

    Ok(())
}
