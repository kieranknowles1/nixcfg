mod constants;
mod reader;
mod value;
mod writer;

use clap::Parser;
use thiserror::Error;

#[derive(Parser)]
enum Opt {
    /// Decode a storage file to JSON on stdout
    Decode {
        /// Input storage binary file
        file: String,
    },
    /// Encode a JSON file to a storage file
    Encode {
        /// Input JSON file, generated by the decode subcommand
        #[clap(short, long)]
        input: String,
        /// Output storage binary file
        #[clap(short, long)]
        output: String,
    },
}

#[derive(Debug, Error)]
enum Error {
    #[error(transparent)]
    Decode(#[from] reader::Error),
    #[error(transparent)]
    Json(#[from] serde_json::Error),
    #[error(transparent)]
    Io(#[from] std::io::Error),
}

type Result<T> = std::result::Result<T, Error>;

fn main() -> Result<()> {
    let opt = Opt::parse();
    match opt {
        Opt::Decode { file } => {
            let data = reader::decode(&file)?;

            let json = serde_json::to_string_pretty(&data)?;

            println!("{}", json);
        }
        Opt::Encode { input, output } => {
            let input = std::fs::File::open(&input)?;
            let data: value::Value = serde_json::from_reader(input)?;

            let mut output = std::fs::File::create(&output)?;
            writer::encode(data, &mut output)?;
            output.sync_all()?;
        }
    }

    Ok(())
}
