use std::{
    ffi::OsStr,
    fs::metadata,
    path::{Path, PathBuf},
};

use serde::Deserialize;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error(transparent)]
    Io(#[from] std::io::Error),
    #[error(transparent)]
    Json(#[from] serde_json::Error),
}

#[derive(Error, Debug)]
#[error("Directory traversal detected: {file}")]
pub struct DirectoryTraversalError {
    file: PathBuf,
}

pub type Result<T> = std::result::Result<T, Error>;

pub type Config = Vec<ConfigEntry>;

pub fn get_previous_config_path(home: &Path) -> PathBuf {
    home.join(".config/activate-mutable-config.json")
}

/// Return `value` if it is `Some`, otherwise use the value of the environment variable `name`.
pub fn or_environ(
    value: Option<PathBuf>,
    name: &str,
) -> std::result::Result<PathBuf, std::env::VarError> {
    match value {
        Some(value) => Ok(value),
        None => Ok(std::env::var(name)?.into()),
    }
}

fn is_directory(path: &Path) -> Result<bool> {
    match metadata(path) {
        Ok(md) => Ok(md.is_dir()),
        Err(err) => match err.kind() {
            std::io::ErrorKind::NotFound => Ok(false),
            _ => Err(err.into()),
        },
    }
}

fn process_config_entry(entry: &ConfigEntry, out: &mut Config) -> Result<()> {
    match is_directory(&entry.source)? {
        true => {
            let children = std::fs::read_dir(&entry.source)?;
            for child in children {
                let child = child?;
                let new_entry = entry.extend(&child.file_name());
                process_config_entry(&new_entry, out)?;
            }
            Ok(())
        }
        false => {
            out.push(entry.clone());
            Ok(())
        }
    }
}

pub fn read_config(file: &Path) -> Result<Config> {
    let file = std::fs::File::open(file)?;
    let json: Config = serde_json::from_reader(file)?;

    let mut out = Vec::new();
    for entry in json {
        process_config_entry(&entry, &mut out)?;
    }
    Ok(out)
}

pub fn find_entry<'a>(entries: &'a Config, path: &Path) -> Option<&'a ConfigEntry> {
    entries.iter().find(|entry| entry.destination == path)
}

fn is_subdirectory(parent: &Path, child: &Path) -> bool {
    child.ancestors().any(|ancestor| ancestor == parent)
}

/// Resolve a possibly absolute path, throwing if it is not a path in the home directory
pub fn resolve_directory(
    home: &Path,
    path: &Path,
) -> std::result::Result<PathBuf, DirectoryTraversalError> {
    let full = home.join(path);
    match is_subdirectory(home, &full) {
        true => Ok(full),
        false => Err(DirectoryTraversalError { file: full }),
    }
}

#[derive(Deserialize, Debug, Clone, Copy)]
#[serde(rename_all = "lowercase")]
pub enum ConflictStrategy {
    Replace,
    Warn,
}

#[derive(Deserialize, Clone)]
#[serde(deny_unknown_fields)]
#[serde(rename_all = "camelCase")]
pub struct ConfigEntry {
    /// Absolute path to the file, typically in the Nix store.
    pub source: PathBuf,
    /// Path of the file in the home directory.
    /// May be relative to the home directory or an absolute path that is in HOME.
    /// Absolute paths pointing outside of HOME will be rejected as a security measure.
    pub destination: PathBuf,
    /// What to do when the file has changed locally.
    pub on_conflict: ConflictStrategy,
    /// Path to the file in the repository, relative to the repository root.
    pub repo_path: Option<String>,
    /// Script to convert a deployed file to a repo file
    /// It is expected to take a single argument: the path of the deployed file,
    /// and to return its output on stdout
    pub transformer: Option<PathBuf>,
    /// If this entry was generated by recursive expansion of a directory,
    /// this will be the destination of the original config.json entry.
    #[serde(skip)]
    pub base_destination: Option<PathBuf>,
}

impl ConfigEntry {
    fn extend(&self, sub_path: &OsStr) -> Self {
        Self {
            source: self.source.join(sub_path),
            destination: self.destination.join(sub_path),
            on_conflict: self.on_conflict,
            repo_path: match &self.repo_path {
                Some(repo_path) => Some(format!("{}/{}", repo_path, sub_path.to_string_lossy())),
                None => None,
            },
            transformer: self.transformer.clone(),
            base_destination: match &self.base_destination {
                Some(base) => Some(base.clone()),
                None => Some(self.destination.clone()),
            },
        }
    }
}
