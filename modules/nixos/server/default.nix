{
  lib,
  config,
  pkgs,
  ...
}: let
  mutexOptionsMsg = ''
    Exactly one of the following options must be specified:
    - `root`
    - `proxyPort`
    - `proxySocket`
  '';
in {
  imports = [
    ./actual.nix
    ./adguard.nix
    ./copyparty.nix
    ./docs.nix
    ./forgejo.nix
    ./homepage
    ./immich.nix
    ./minecraft.nix
    ./paperless.nix
    ./ports.nix
    ./postgresql.nix
    ./search.nix
    ./authelia
    ./trilium.nix
  ];

  options.custom.server = let
    inherit (lib) mkOption mkEnableOption types;

    mkHostOpt = type: example: description:
      mkOption {
        inherit example;
        type = types.nullOr type;
        default = null;
        description = "${description}\n${mutexOptionsMsg}";
      };

    vhostOpts = {
      root =
        mkHostOpt types.path "/path/to/html"
        "Absolute path to the root directory to be served.";
      proxyPort =
        mkHostOpt types.port 8080
        "The port to proxy connections to.";
      proxySocket =
        mkHostOpt types.path "/path/to/socket.sock"
        "Absolute path to socket to proxy connections to.";

      useCloudflareProxy = mkOption {
        type = types.bool;
        default = true;
        example = false;
        description = ''
          Proxy requests through CloudFlare. Preferred as it provides additional
          security (filter traffic from other countries) and performance
          (caching of static assets). But limits uploads to 100MB per request
          as I am on the free tier.

          Make sure to add a non proxied DNS record for the subdomain!
        '';
      };

      webSockets = mkEnableOption "websockets";

      cache.enable = mkEnableOption "add cache headers to this vhost";
      cache.expires = mkOption {
        type = types.str;
        default = "12w";
        description = ''
          The `cache-control max-age` header value as an Nginx
          [time string](https://nginx.org/en/docs/syntax.html)
        '';
      };
    };

    subdomainType = types.submodule {
      # Auth is not supported for the root domain. No need for it currently
      # so not bothering with implementation
      options =
        vhostOpts
        // {
          # NOTE: This is implemented in the `authelia` module.
          # ACL rules are much more complex than this, but this gives a
          # good enough starting point for most use cases.
          authorization = let
            authEnum = types.enum [
              "none"
              "one_factor"
              "two_factor"
            ];
          in {
            policy = mkOption {
              type = authEnum;
              default = "none";
              description = ''
                Authorization policy for this vhost. Values other than `none`
                require that Authelia is configured.
                - None: No authentication or authorization required.
                - One Factor: Username and password required.
                - Two Factor: Username, password, and 2FA required.
              '';
            };
            subject = let
              strList = types.listOf types.str;
            in
              mkOption {
                type = types.nullOr (types.either strList (types.listOf strList));
                example = ["group:admins"];
                description = ''
                  Authelia subjects to restrict access to. If null, all authenticated
                  users are authorized. A user is granted access if they match ANY subject.
                  If an entry is a list, it applies as an AND condition.
                  `["group:admins" "group:dev"]` would require that a user is both
                  an admin and a developer.


                  See [Authelia Documentation](https://www.authelia.com/configuration/security/access-control/)
                  for more information on subjects.
                '';
              };
          };
        };
    };
  in {
    enable = mkEnableOption "server hosting";

    hostname = mkOption {
      type = types.str;
      example = "example.com";
      description = "The domain name of the server";
    };

    ssl = {
      publicKeyFile = mkOption {
        type = types.path;
        example = "/path/to/public.pem";
        description = ''
          Path to a public certificate file generated by
          [CloudFlare's origin CA](https://developers.cloudflare.com/ssl/origin-configuration/origin-ca/).
        '';
      };
      privateKeySecret = mkOption {
        type = types.str;
        example = "ssl/private-key";
        description = ''
          SOPS secret path to the private key file generated by
          [CloudFlare's origin CA](https://developers.cloudflare.com/ssl/origin-configuration/origin-ca/).
        '';
      };
    };

    root = vhostOpts;
    localRoot = vhostOpts;
    subdomains = mkOption {
      type = types.attrsOf subdomainType;
      default = {};
      description = "Subdomains to serve on the server";
    };

    data = {
      baseDirectory = mkOption {
        type = types.path;
        example = "/path/to/server/data";
        description = ''
          Base directory for storing server data. Should be backed up regularly.

          Services will use subdirectories within this unless configured otherwise.
        '';
      };
    };

    clearCacheKey = mkOption {
      type = types.str;
      default = "cloudflare/clearcache-key";
      description = ''
        SOPS secret path to a Cloudflare API key with the `Cache Purge` permission.
        Permission should be restricted to the zone ass
      '';
    };

    zoneIdSecret = mkOption {
      type = types.str;
      default = "cloudflare/zoneid";
      description = ''
        SOPS secret path to a Cloudflare zone ID.
      '';
    };
  };

  config = let
    cfg = config.custom.server;

    authelia-location = pkgs.writeText "authelia-location.conf" ''
      # https://www.authelia.com/integration/proxies/nginx/#standard-example
      set $upstream_authelia http://unix:${cfg.authelia.socket}:/api/authz/auth-request;

      ## Virtual endpoint created by nginx to forward auth requests.
      location /internal/authelia/authz {
          ## Essential Proxy Configuration
          internal;
          proxy_pass $upstream_authelia;

          ## Headers
          ## The headers starting with X-* are required.
          proxy_set_header X-Original-Method $request_method;
          proxy_set_header X-Original-URL $scheme://$http_host$request_uri;
          proxy_set_header X-Forwarded-For $remote_addr;
          proxy_set_header Content-Length "";
          proxy_set_header Connection "";

          ## Basic Proxy Configuration
          proxy_pass_request_body off;
          proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; # Timeout if the real server is dead
          proxy_redirect http:// $scheme://;
          proxy_http_version 1.1;
          proxy_cache_bypass $cookie_session;
          proxy_no_cache $cookie_session;
          proxy_buffers 4 32k;
          client_body_buffer_size 128k;

          ## Advanced Proxy Configuration
          send_timeout 5m;
          proxy_read_timeout 240;
          proxy_send_timeout 240;
          proxy_connect_timeout 240;
      }
    '';

    authelia-authrequest = pkgs.writeText "authelia-authrequest.conf" ''
      # https://www.authelia.com/integration/proxies/nginx/#standard-example
      ## Send a subrequest to Authelia to verify if the user is authenticated and has permission to access the resource.
      auth_request /internal/authelia/authz;

      ## Save the upstream metadata response headers from Authelia to variables.
      auth_request_set $user $upstream_http_remote_user;
      auth_request_set $groups $upstream_http_remote_groups;
      auth_request_set $name $upstream_http_remote_name;
      auth_request_set $email $upstream_http_remote_email;

      ## Inject the metadata response headers from the variables into the request made to the backend.
      proxy_set_header Remote-User $user;
      proxy_set_header Remote-Groups $groups;
      proxy_set_header Remote-Email $email;
      proxy_set_header Remote-Name $name;

      ## Configure the redirection when the authz failure occurs. Lines starting with 'Modern Method' and 'Legacy Method'
      ## should be commented / uncommented as pairs. The modern method uses the session cookies configuration's authelia_url
      ## value to determine the redirection URL here. It's much simpler and compatible with the mutli-cookie domain easily.

      ## Modern Method: Set the $redirection_url to the Location header of the response to the Authz endpoint.
      auth_request_set $redirection_url $upstream_http_location;

      ## Modern Method: When there is a 401 response code from the authz endpoint redirect to the $redirection_url.
      error_page 401 =302 $redirection_url;

      ## Legacy Method: Set $target_url to the original requested URL.
      ## This requires http_set_misc module, replace 'set_escape_uri' with 'set' if you don't have this module.
      # set_escape_uri $target_url $scheme://$http_host$request_uri;

      ## Legacy Method: When there is a 401 response code from the authz endpoint redirect to the portal with the 'rd'
      ## URL parameter set to $target_url. This requires users update 'auth.example.com/' with their external authelia URL.
      # error_page 401 =302 https://auth.example.com/?rd=$target_url;
    '';

    # From nixpkgs nginx
    # Mime.types values are taken from brotli sample configuration - https://github.com/google/ngx_brotli
    # and Nginx Server Configs - https://github.com/h5bp/server-configs-nginx
    compressMimeTypes = [
      "application/atom+xml"
      "application/geo+json"
      "application/javascript" # Deprecated by IETF RFC 9239, but still widely used
      "application/json"
      "application/ld+json"
      "application/manifest+json"
      "application/rdf+xml"
      "application/vnd.ms-fontobject"
      "application/wasm"
      "application/x-rss+xml"
      "application/x-web-app-manifest+json"
      "application/xhtml+xml"
      "application/xliff+xml"
      "application/xml"
      "font/collection"
      "font/otf"
      "font/ttf"
      "image/bmp"
      "image/svg+xml"
      "image/vnd.microsoft.icon"
      "text/cache-manifest"
      "text/calendar"
      "text/css"
      "text/csv"
      "text/html"
      "text/javascript"
      "text/markdown"
      "text/plain"
      "text/vcard"
      "text/vnd.rim.location.xloc"
      "text/vtt"
      "text/x-component"
      "text/xml"
    ];

    precompress = root: (pkgs.runCommand "static-precompressed" {
        buildInputs = [pkgs.gzip];
      } ''
        COMPRESS_MIMES="${builtins.concatStringsSep "|" compressMimeTypes}"
        mkdir -p $out

        while read -r file; do
          # Replace $src with $out
          outfile="$out/$(realpath --relative-to ${root} "$file")"
          mkdir -p "$(dirname "$outfile")"
          ln -s "$file" "$outfile"

          # Only compress files that Nginx will serve compressed
          mime="$(file --mime-type -b $file)"
          if [[ "$COMPRESS_MIMES" == *"$mime"* ]]; then
            gzip -9 --stdout "$file" > "$outfile.gz"
          fi
        done < <(find "${root}" -type f)
      '');

    mkVhost = isRoot: subdomain: ssl: let
      # Authorization is not currently supported for the root domain. (plain selwonk.uk)
      requireAuth = !isRoot && subdomain.authorization.policy != "none";
    in {
      locations."/" = {
        # Pre-compress static files, recommendedGzipSettings sets gzip_static on;
        # which will serve $file.gz if it exists, saving bandwidth and CPU cycles.
        root = lib.mkIf (subdomain.root != null) (precompress subdomain.root);

        # inherit (subdomain) root;
        proxyPass =
          if subdomain.proxyPort != null
          then "http://localhost:${toString subdomain.proxyPort}"
          else if subdomain.proxySocket != null
          then "http://unix:${toString subdomain.proxySocket}"
          else null;

        proxyWebsockets = subdomain.webSockets;

        extraConfig = ''
          ${lib.optionalString requireAuth "include ${authelia-authrequest};"}
        '';
      };

      # TODO: Self-signed certificates for local networks
      forceSSL = ssl; # Enable HTTPS and redirect HTTP to it, unless it's a local network where we don't generate certificates
      enableACME = ssl && !subdomain.useCloudflareProxy;

      # We're not using ACME as it's incompatible with Cloudflare proxies
      # I'd rather not turn that off to reduce load from scraping, public pages
      # are static and should have high cache hit rates
      #
      # Instead, use a Cloudflare origin CA, which is only recognised by
      # Cloudflare's proxy to keep traffic secure
      sslCertificate = cfg.ssl.publicKeyFile;
      sslCertificateKey = config.sops.secrets.ssl-private-key.path;

      extraConfig = ''
        ${lib.optionalString subdomain.cache.enable "expires ${subdomain.cache.expires};"}
        ${lib.optionalString requireAuth "include ${authelia-location};"}
      '';
    };

    isSet = val: val != null;

    mkSubHosts = ssl: tld:
      lib.attrsets.mapAttrs' (name: subdomain: {
        name = "${name}.${tld}";
        value = mkVhost false subdomain ssl;
      })
      cfg.subdomains;
  in
    lib.mkIf cfg.enable {
      assertions =
        lib.attrsets.mapAttrsToList (name: subdomain: {
          assertion =
            builtins.length (builtins.filter isSet [
              subdomain.root
              subdomain.proxyPort
              subdomain.proxySocket
            ])
            == 1;
          message = "config.custom.server.subdomains.${name}: \n${mutexOptionsMsg}";
        })
        cfg.subdomains;

      sops.secrets = let
        mkSecret = owner: key: {
          inherit owner key;
        };
      in {
        ssl-private-key = mkSecret config.services.nginx.user cfg.ssl.privateKeySecret;

        cf-zone-id = mkSecret "root" cfg.zoneIdSecret;
        cf-clearcache-token = mkSecret "root" cfg.clearCacheKey;
      };

      services.nginx = {
        enable = true;
        # Compress responses using sensible defaults
        recommendedGzipSettings = true;
        # Apply sensible defaults to reverse proxies
        recommendedProxySettings = true;

        # Allow larger uploads, needed for things like Immich
        clientMaxBodySize = "50000m";

        # *.local can't use aliases since we don't have a certificate for .local,
        # meaning clients will complain about invalid certificates
        virtualHosts = lib.mkMerge [
          (mkSubHosts true cfg.hostname)
          (mkSubHosts false "${config.networking.hostName}.local")
          {
            "${cfg.hostname}" = mkVhost true cfg.root true;
            "${config.networking.hostName}.local" = mkVhost true cfg.localRoot false;

            # 404 for any unknown subdomains
            "_default" = {
              default = true;
              locations."/".return = 404;

              forceSSL = true; # Enable HTTPS and redirect HTTP to it
              sslCertificate = cfg.ssl.publicKeyFile;
              sslCertificateKey = config.sops.secrets.ssl-private-key.path;
            };
          }
        ];
      };

      security.acme = {
        acceptTerms = true;
        email = "contact@${cfg.hostname}";
      };

      networking.firewall.allowedTCPPorts = with cfg.ports.tcp; [http https];

      environment.systemPackages = lib.singleton (pkgs.writeShellScriptBin "clear-cloudflare-cache" ''
        set -euo pipefail

        ZONE_ID=$(cat ${config.sops.secrets.cf-zone-id.path})
        CLEAR_CACHE_TOKEN=$(cat ${config.sops.secrets.cf-clearcache-token.path})

        curl "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/purge_cache" \
          --header 'Content-Type: application/json' \
          --header "Authorization: Bearer $CLEAR_CACHE_TOKEN" \
          --data '{"purge_everything": true}'
      '');
    };
}
